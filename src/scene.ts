import { Composer, Middleware, MiddlewareFn } from "grammy"
import { SafeDictionary } from "ts-essentials"

import { SceneFlavoredContext, ScenesFlavoredContext } from "."

export class Scene<
	C extends ScenesFlavoredContext = ScenesFlavoredContext,
	S = undefined
> extends Composer<SceneFlavoredContext<C, S>> {
	_always?: Composer<SceneFlavoredContext<C, S>>
	steps: Array<Composer<SceneFlavoredContext<C, S>>> = []
	pos_by_label: SafeDictionary<number> = {}

	constructor(public readonly id: string) {
		super()
	}

	use(...middleware: Array<Middleware<SceneFlavoredContext<C, S>>>) {
		const composer = super.use(...middleware)
		this.steps.push(composer)
		return composer
	}

	always(...middleware: Array<Middleware<SceneFlavoredContext<C, S>>>) {
		this._always ??= new Composer<SceneFlavoredContext<C, S>>()
		this._always.use(...middleware)
		return this._always
	}

	/** Set payload for ctx.scene.arg in next step */
	arg(arg: any) {
		this.do((ctx) => {
			ctx.scene.next_arg = arg
		})
	}

	/** Break scene middleware flow, wait for new updates. */
	wait(...middleware: Array<Middleware<SceneFlavoredContext<C, S>>>) {
		this.use((ctx) => {
			ctx.scene.wait()
		})
		return this.mustResume(...middleware)
	}

	/** This middleware must call ctx.scene.resume() to go to the next middleware. */
	mustResume(...middleware: Array<Middleware<SceneFlavoredContext<C, S>>>) {
		const composer = new Composer<SceneFlavoredContext<C, S>>((ctx, next) => {
			ctx.scene.mustResume()
			return next()
		}, ...middleware)
		this.steps.push(composer)
		return composer
	}

	/** Call nested scene, then go to the next step. */
	call(sceneId: string, arg?: any) {
		this.do((ctx) => ctx.scene.call(sceneId, arg))
	}

	/** Exit scene. */
	exit(arg?: any) {
		this.do((ctx) => ctx.scene.exit(arg))
	}

	/** Go to scene step marked with scene.label() */
	goto(label: string, arg?: any) {
		this.do((ctx) => ctx.scene.goto(label, arg))
	}

	/** Mark a named position in scene to be used by scene.goto() */
	label(label: string) {
		this.pos_by_label[label] = this.steps.length
	}

	middleware() {
		throw Error(`Scene is not supposed to be used directly as a middleware.`)
		return super.middleware() // Prevent type error
	}
}

/**
 * Predicate to filter contexts generated by ctx.scenes.resume()
 * See also composer.resume() shortcut.
 * */
export function filterResume(
	ctx: SceneFlavoredContext<ScenesFlavoredContext, any>
) {
	return ctx.scene?.opts?.resume === true
}
